import concurrent.futures
from exchangelib import Credentials, Account
import pandas as pd
import time

# Set your Exchange credentials
EMAIL = "your.email@company.com"
PASSWORD = "your_password"

# Connect to Exchange
try:
    print("Connecting to Exchange...")
    credentials = Credentials(EMAIL, PASSWORD)
    account = Account(EMAIL, credentials=credentials, autodiscover=True)
    print("‚úÖ Connected to Exchange successfully!")

except Exception as e:
    print(f"‚ùå ERROR: Unable to connect to Exchange. {e}")
    exit()

# Character set to iterate over GAL efficiently
search_prefixes = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@._")

# Function to safely extract a value from user[1] or return default
def safe_extract(user, attr, default="N/A"):
    """Safely extract an attribute from user[1] or return default if missing."""
    try:
        return getattr(user[1], attr) if hasattr(user[1], attr) and getattr(user[1], attr) else default
    except:
        return default

# Function to fetch GAL contacts in batches
def fetch_contacts(prefix):
    try:
        print(f"üìå Fetching contacts starting with: {prefix}* ...")

        resolved_names = account.protocol.resolve_names(prefix + "*", return_full_contact_data=True)
        contacts = []

        for user in resolved_names:
            if user and isinstance(user, tuple) and len(user) > 1:  # Ensure user[1] exists
                job_title = safe_extract(user, "job_title", "").strip()

                # ‚úÖ Skip contacts where Job Title is empty
                if not job_title:
                    continue  

                # Extract fields based on Exchange data format (using user[1])
                full_name = safe_extract(user, "display_name")
                first_name = safe_extract(user, "given_name")
                last_name = safe_extract(user, "surname")

                # ‚úÖ Extract email from EmailAddress tuple inside user[1]
                email = "N/A"
                if hasattr(user[1], "email_addresses") and isinstance(user[1].email_addresses, tuple):
                    for email_obj in user[1].email_addresses:
                        if hasattr(email_obj, "email"):
                            email = email_obj.email
                            break  # Get only the first available email

                department = safe_extract(user, "department")
                office_location = safe_extract(user, "office")

                # ‚úÖ Extract address details from PhysicalAddress tuple
                city, state, country = "N/A", "N/A", "N/A"
                if hasattr(user[1], "physical_addresses") and isinstance(user[1].physical_addresses, tuple):
                    for address in user[1].physical_addresses:
                        if hasattr(address, "label") and address.label == "Business":
                            city = safe_extract(address, "city")
                            state = safe_extract(address, "state")
                            country = safe_extract(address, "country")

                # ‚úÖ Extract phone numbers from PhoneNumber tuple
                work_phone, mobile = "N/A", "N/A"
                if hasattr(user[1], "phone_numbers") and isinstance(user[1].phone_numbers, tuple):
                    for phone in user[1].phone_numbers:
                        if hasattr(phone, "label") and phone.label == "BusinessPhone":
                            work_phone = safe_extract(phone, "phone_number")
                        elif hasattr(phone, "label") and phone.label == "MobilePhone":
                            mobile = safe_extract(phone, "phone_number")

                # ‚úÖ Extract manager name
                manager = "N/A"
                if hasattr(user[1], "manager") and user[1].manager:
                    manager = safe_extract(user[1].manager, "name")

                # ‚úÖ Count direct reports
                direct_reports_count = 0
                if hasattr(user[1], "direct_reports") and isinstance(user[1].direct_reports, tuple):
                    direct_reports_count = len(user[1].direct_reports)

                contacts.append([
                    full_name, first_name, last_name, email, job_title, department, office_location,
                    city, state, country, work_phone, mobile, manager, direct_reports_count
                ])
        
        print(f"‚úÖ Completed: {prefix}* - {len(contacts)} valid contacts (Job Title Required)")
        return contacts

    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching GAL for prefix '{prefix}': {e}")
        return []

# Multithreading Execution
contacts = []
start_time = time.time()

# Use ThreadPoolExecutor to fetch data in multiple threads
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    futures = [executor.submit(fetch_contacts, prefix) for prefix in search_prefixes]

# Collect results
for future in concurrent.futures.as_completed(futures):
    contacts.extend(future.result())

# Convert to DataFrame
df = pd.DataFrame(contacts, columns=[
    "Full Name", "First Name", "Last Name", "Email", "Job Title", "Department", "Office Location",
    "City", "State", "Country", "Work Phone", "Mobile", "Manager Name", "Direct Reports Count"
])

# Save to CSV
output_file = "C:\\Users\\Public\\GAL_EWS_Contacts.csv"
df.to_csv(output_file, index=False, encoding="utf-8")

# Print execution summary
elapsed_time = time.time() - start_time
print(f"\n‚úÖ Export completed successfully! Data saved to {output_file}")
print(f"üîπ Total Valid Records Processed: {len(contacts)} (Excluding empty job titles)")
print(f"‚è≥ Total Execution Time: {elapsed_time:.2f} seconds")

import concurrent.futures
from exchangelib import Credentials, Account
import pandas as pd
import time
import string

# Set your Exchange credentials
EMAIL = "your.email@company.com"
PASSWORD = "your_password"

# Connect to Exchange
try:
    print("Connecting to Exchange...")
    credentials = Credentials(EMAIL, PASSWORD)
    account = Account(EMAIL, credentials=credentials, autodiscover=True)
    print("âœ… Connected to Exchange successfully!")

except Exception as e:
    print(f"âŒ ERROR: Unable to connect to Exchange. {e}")
    exit()

# Character set to iterate over GAL efficiently
search_prefixes = list(string.ascii_uppercase + "0123456789@._")

# âœ… Function to recursively fetch contacts if more than 100 exist per query
def fetch_contacts(prefix, depth=1):
    """Recursively fetch contacts by refining the search query if needed."""
    try:
        contacts = []
        query = prefix + "*"

        print(f"ðŸ“Œ Fetching contacts starting with: {query} ...")
        resolved_names = account.protocol.resolve_names(query, return_full_contact_data=True)

        if not resolved_names:
            return []

        for user in resolved_names:
            if user and isinstance(user, tuple) and len(user) > 1:  # Ensure user[1] exists
                job_title = user[1].job_title if hasattr(user[1], "job_title") else ""

                # âœ… Skip contacts where Job Title is empty
                if not job_title.strip():
                    continue  

                # âœ… Extract Email from `user[0].email_address` (inside Mailbox)
                email = user[0].email_address if hasattr(user[0], "email_address") else "N/A"

                # âœ… Extract Other Fields from `user[1]`
                full_name = user[1].display_name if hasattr(user[1], "display_name") else "N/A"
                first_name = user[1].given_name if hasattr(user[1], "given_name") else "N/A"
                last_name = user[1].surname if hasattr(user[1], "surname") else "N/A"
                department = user[1].department if hasattr(user[1], "department") else "N/A"
                office_location = user[1].office_location if hasattr(user[1], "office_location") else "N/A"

                # âœ… Extract Address (City, State, Country) from `user[1].physical_addresses`
                city, state, country = "N/A", "N/A", "N/A"
                if hasattr(user[1], "physical_addresses") and isinstance(user[1].physical_addresses, tuple):
                    for address in user[1].physical_addresses:
                        if hasattr(address, "label") and address.label == "Business":
                            city = address.city if hasattr(address, "city") else "N/A"
                            state = address.state if hasattr(address, "state") else "N/A"
                            country = address.country if hasattr(address, "country") else "N/A"

                # âœ… Extract Phone Numbers (Work & Mobile) from `user[1].phone_numbers`
                work_phone, mobile = "N/A", "N/A"
                if hasattr(user[1], "phone_numbers") and isinstance(user[1].phone_numbers, tuple):
                    for phone in user[1].phone_numbers:
                        if hasattr(phone, "label") and phone.label == "BusinessPhone":
                            work_phone = phone.phone_number if hasattr(phone, "phone_number") else "N/A"
                        elif hasattr(phone, "label") and phone.label == "MobilePhone":
                            mobile = phone.phone_number if hasattr(phone, "phone_number") else "N/A"

                # âœ… Extract Manager Name from `user[1].manager`
                manager = user[1].manager.name if hasattr(user[1], "manager") and user[1].manager else "N/A"

                # âœ… Count Direct Reports from `user[1].direct_reports`
                direct_reports_count = len(user[1].direct_reports) if hasattr(user[1], "direct_reports") and isinstance(user[1].direct_reports, tuple) else 0

                contacts.append([
                    full_name, first_name, last_name, email, job_title, department, office_location,
                    city, state, country, work_phone, mobile, manager, direct_reports_count
                ])

        print(f"âœ… Completed: {query} - {len(contacts)} valid contacts (Job Title Required)")

        # âœ… If exactly 100 results were returned, we need more refined queries
        if len(resolved_names) == 100 and depth < 3:  # Limit depth to prevent infinite loops
            for letter in string.ascii_uppercase:  # A-Z
                contacts += fetch_contacts(prefix + letter, depth + 1)
            for digit in "0123456789":  # 0-9
                contacts += fetch_contacts(prefix + digit, depth + 1)

        return contacts

    except Exception as e:
        print(f"âš ï¸ Error fetching GAL for prefix '{prefix}': {e}")
        return []

# Multithreading Execution
contacts = []
start_time = time.time()

# Use ThreadPoolExecutor to fetch data in multiple threads
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    futures = [executor.submit(fetch_contacts, prefix) for prefix in search_prefixes]

# Collect results
for future in concurrent.futures.as_completed(futures):
    contacts.extend(future.result())

# Convert to DataFrame
df = pd.DataFrame(contacts, columns=[
    "Full Name", "First Name", "Last Name", "Email", "Job Title", "Department", "Office Location",
    "City", "State", "Country", "Work Phone", "Mobile", "Manager Name", "Direct Reports Count"
])

# Save to CSV
output_file = "C:\\Users\\Public\\GAL_EWS_Contacts.csv"
df.to_csv(output_file, index=False, encoding="utf-8")

# Print execution summary
elapsed_time = time.time() - start_time
print(f"\nâœ… Export completed successfully! Data saved to {output_file}")
print(f"ðŸ”¹ Total Valid Records Processed: {len(contacts)} (Excluding empty job titles)")
print(f"â³ Total Execution Time: {elapsed_time:.2f} seconds")

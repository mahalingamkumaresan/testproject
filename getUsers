import concurrent.futures
from exchangelib import Credentials, Account
import pandas as pd
import time
import string
import re  # Used to extract Standard ID

# Set your Exchange credentials
EMAIL = "your.email@company.com"
PASSWORD = "your_password"

# Connect to Exchange
try:
    print("Connecting to Exchange...")
    credentials = Credentials(EMAIL, PASSWORD)
    account = Account(EMAIL, credentials=credentials, autodiscover=True)
    print("âœ… Connected to Exchange successfully!")

except Exception as e:
    print(f"âŒ ERROR: Unable to connect to Exchange. {e}")
    exit()

# Character set to iterate over GAL efficiently
search_prefixes = list(string.ascii_uppercase + "0123456789@._")

# Function to extract Standard ID from name format "LastName, FirstName STANDARDID"
def extract_standard_id(name):
    if name:
        match = re.search(r'\b(\w+)$', name)  # Extracts last word (Standard ID)
        return match.group(1) if match else "N/A"
    return "N/A"

# Function to fetch contacts in batches (handles pagination)
def fetch_contacts(prefix, depth=1):
    """Recursively fetch contacts by refining the search query if needed."""
    try:
        contacts = []
        query = prefix + "*"

        print(f"ðŸ“Œ Fetching contacts starting with: {query} ...")
        resolved_names = account.protocol.resolve_names(query, return_full_contact_data=True)

        if not resolved_names:
            return []

        for user in resolved_names:
            if user and isinstance(user, tuple) and len(user) > 1:  # Ensure user[1] exists
                job_title = user[1].job_title if hasattr(user[1], "job_title") else ""

                # âœ… Skip contacts where Job Title is empty
                if not job_title.strip():
                    continue  

                # âœ… Extract Email from `user[0].email_address` (inside Mailbox)
                email = user[0].email_address if hasattr(user[0], "email_address") else "N/A"

                # âœ… Extract Display Name (Removing First/Last Name from Output)
                display_name = user[1].display_name if hasattr(user[1], "display_name") else "N/A"

                # âœ… Extract Standard ID from `user[0].name`
                standard_id = extract_standard_id(user[0].name) if hasattr(user[0], "name") else "N/A"

                # âœ… Extract Job Title, Department, Office Location
                department = user[1].department if hasattr(user[1], "department") else "N/A"
                office_location = user[1].office_location if hasattr(user[1], "office_location") else "N/A"

                # âœ… Extract Address (City, Country, Zip) from `user[1].physical_addresses[0]`
                city, country, zip_code = "N/A", "N/A", "N/A"
                if hasattr(user[1], "physical_addresses") and isinstance(user[1].physical_addresses, tuple) and len(user[1].physical_addresses) > 0:
                    address = user[1].physical_addresses[0]  # Use first address
                    city = address.city if hasattr(address, "city") else "N/A"
                    country = address.country if hasattr(address, "country") else "N/A"
                    zip_code = address.zipcode if hasattr(address, "zipcode") else "N/A"

                # âœ… Extract Phone Numbers (Work & Mobile) from `user[1].phone_numbers`
                work_phone, mobile = "N/A", "N/A"
                if hasattr(user[1], "phone_numbers") and isinstance(user[1].phone_numbers, tuple):
                    for phone in user[1].phone_numbers:
                        if hasattr(phone, "label") and phone.label == "BusinessPhone":
                            work_phone = phone.phone_number if hasattr(phone, "phone_number") else "N/A"
                        elif hasattr(phone, "label") and phone.label == "MobilePhone":
                            mobile = phone.phone_number if hasattr(phone, "phone_number") else "N/A"

                # âœ… Extract Manager Name and Manager Standard ID
                manager_name = user[1].manager.name if hasattr(user[1], "manager") and user[1].manager else "N/A"
                manager_standard_id = extract_standard_id(manager_name)

                # âœ… Count Direct Reports from `user[1].direct_reports`
                direct_reports_count = len(user[1].direct_reports) if hasattr(user[1], "direct_reports") and isinstance(user[1].direct_reports, tuple) else 0

                contacts.append([
                    display_name, standard_id, email, job_title, department, office_location,
                    city, country, zip_code, work_phone, mobile, manager_name, manager_standard_id, direct_reports_count
                ])

        print(f"âœ… Completed: {query} - {len(contacts)} valid contacts (Job Title Required)")

        # âœ… If exactly 100 results were returned, we need more refined queries
        if len(resolved_names) == 100 and depth < 3:  # Limit depth to prevent infinite loops
            for letter in string.ascii_uppercase:  # A-Z
                contacts += fetch_contacts(prefix + letter, depth + 1)
            for digit in "0123456789":  # 0-9
                contacts += fetch_contacts(prefix + digit, depth + 1)

        return contacts

    except Exception as e:
        print(f"âš ï¸ Error fetching GAL for prefix '{prefix}': {e}")
        return []

# Multithreading Execution
contacts = []
start_time = time.time()

# Use ThreadPoolExecutor to fetch data in multiple threads
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    futures = [executor.submit(fetch_contacts, prefix) for prefix in search_prefixes]

# Collect results
for future in concurrent.futures.as_completed(futures):
    contacts.extend(future.result())

# Convert to DataFrame
df = pd.DataFrame(contacts, columns=[
    "Display Name", "Standard ID", "Email", "Job Title", "Department", "Office Location",
    "City", "Country", "Zip Code", "Work Phone", "Mobile", "Manager Name", "Manager Standard ID", "Direct Reports Count"
])

# Save to CSV
output_file = "C:\\Users\\Public\\GAL_EWS_Contacts.csv"
df.to_csv(output_file, index=False, encoding="utf-8")

# Print execution summary
elapsed_time = time.time() - start_time
print(f"\nâœ… Export completed successfully! Data saved to {output_file}")
print(f"ðŸ”¹ Total Valid Records Processed: {len(contacts)} (Excluding empty job titles)")
print(f"â³ Total Execution Time: {elapsed_time:.2f} seconds")
zzz
